!-----------------------------------------------------------------------------
! (c) Crown copyright 2021 Met Office. All rights reserved.
! The file LICENCE, distributed with this code, contains details of the terms
! under which the code may be used.
!-----------------------------------------------------------------------------

!> Test the q3t matrix

module eliminated_theta_q3t_kernel_mod_test

  use constants_mod, only : i_def, r_def
  use pFUnit_Mod
  use yaxt,          only : xt_initialize, xt_finalize
  use mpi_mod,       only : store_comm, clear_comm

  implicit none

  private
  public :: test_all

  @TestCase
  type, extends(MPITestCase), public :: eliminated_theta_q3t_test_type
    private
  contains
    procedure setUp
    procedure tearDown
    procedure test_all
  end type eliminated_theta_q3t_test_type

contains

  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  subroutine setUp( this )

    use finite_element_config_mod, only : cellshape_quadrilateral, &
                                          coord_system_xyz
    use feign_config_mod,          only : feign_finite_element_config

    implicit none

    class(eliminated_theta_q3t_test_type), intent(inout) :: this

    ! Initialise YAXT
    call xt_initialize(this%getMpiCommunicator())
    ! Store the MPI communicator for later use
    call store_comm(this%getMpiCommunicator())

    call feign_finite_element_config(           &
             cellshape=cellshape_quadrilateral, &
             coord_order=0_i_def,               &
             element_order=0_i_def,             &
             rehabilitate=.true.,               &
             coord_system=coord_system_xyz,     &
             vorticity_in_w1=.false. )

  end subroutine setUp

  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  subroutine tearDown( this )

    use configuration_mod, only: final_configuration

    implicit none

    class(eliminated_theta_q3t_test_type), intent(inout) :: this

    call final_configuration()

    ! Finalise YAXT
    call xt_finalize()
    ! Clear the stored MPI communicator
    call clear_comm()

  end subroutine tearDown

  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

  @Test( npes=[1] )
  subroutine test_all( this )

    use eliminated_theta_q3t_kernel_mod, only : eliminated_theta_q3t_code

    implicit none

    class(eliminated_theta_q3t_test_type), intent(inout) :: this

    real(kind=r_def), parameter :: tol = 1.0e-12_r_def

    ! Mesh
    integer(kind=i_def), parameter :: ncell   = 1
    integer(kind=i_def), parameter :: nlayers = 1
    integer(kind=i_def), parameter :: cell    = 1

    ! Array sizes
    integer(kind=i_def), parameter :: ndf_w3 = 1_i_def
    integer(kind=i_def), parameter :: ndf_wt = 2_i_def
    integer(kind=i_def), parameter :: ndf_wx = 8_i_def
    integer(kind=i_def), parameter :: ndf_p  = 1_i_def
    integer(kind=i_def), parameter :: undf_wt = ndf_wt
    integer(kind=i_def), parameter :: undf_wx = ndf_wx
    integer(kind=i_def), parameter :: undf_p  = ndf_p
    ! Operators to test
    real(kind=r_def), dimension(ndf_w3,ndf_wt,ncell) :: q3t
    ! Maps
    integer(kind=i_def), dimension(ndf_wx) :: map_wx
    integer(kind=i_def), dimension(ndf_wt) :: map_wt
    integer(kind=i_def), dimension(ndf_p)  :: map_p
    ! Basis arrays
    real(kind=r_def), dimension(1,ndf_w3) :: basis_w3
    real(kind=r_def), dimension(1,ndf_wt) :: basis_wt
    real(kind=r_def), dimension(1,ndf_wx) :: basis_wx
    real(kind=r_def), dimension(3,ndf_wx) :: diff_basis_wx
    ! Quadrature
    integer(kind=i_def), parameter   :: nqp = 1_i_def
    real(kind=r_def), dimension(nqp) :: wgt
    ! Fields
    real(kind=r_def), dimension(ndf_wt) :: theta
    real(kind=r_def), dimension(ndf_p)  :: panel_id
    ! Coordinate fields
    real(kind=r_def), dimension(ndf_wx) :: x, y, z
    real(kind=r_def)                    :: dx, dy, dz, zero
    ! Operators
    real(kind=r_def), dimension(ndf_w3,ndf_w3,ncell) :: inv_m3

    integer(kind=i_def) :: i, df1, df2
    real(kind=r_def), dimension(ndf_w3, ndf_wt) :: answer

    ! Set cell coordinates
    dx = 2.0_r_def
    dy = 3.0_r_def
    dz = 4.0_r_def
    zero = 0.0_r_def
    x = (/ zero, dx,   dx,   zero, zero, dx,   dx, zero /)
    y = (/ zero, zero, dy,   dy,   zero, zero, dy, dy /)
    z = (/ zero, zero, zero, zero, dz,   dz,   dz, dz /)

    do i = 1,ndf_wx
      map_wx(i) = int(i,i_def)
    end do
    do i = 1,ndf_wt
      map_wt(i) = int(i,i_def)
    end do
    do i = 1,ndf_p
      map_p(i) = int(i,i_def)
    end do

    ! Quadrature
    wgt(:) = 1.0_r_def

    ! Basis functions
    basis_w3(:,:) = 1.0_r_def

    basis_wt(:,:) = 0.5_r_def

    ! Coordinate basis
    diff_basis_wx(:,1) = (/ -1.0_r_def, -1.0_r_def, -1.0_r_def /)
    diff_basis_wx(:,2) = (/  1.0_r_def, -1.0_r_def, -1.0_r_def /)
    diff_basis_wx(:,3) = (/  1.0_r_def,  1.0_r_def, -1.0_r_def /)
    diff_basis_wx(:,4) = (/ -1.0_r_def,  1.0_r_def, -1.0_r_def /)
    diff_basis_wx(:,5) = (/ -1.0_r_def, -1.0_r_def,  1.0_r_def /)
    diff_basis_wx(:,6) = (/  1.0_r_def, -1.0_r_def,  1.0_r_def /)
    diff_basis_wx(:,7) = (/  1.0_r_def,  1.0_r_def,  1.0_r_def /)
    diff_basis_wx(:,8) = (/ -1.0_r_def,  1.0_r_def,  1.0_r_def /)
    diff_basis_wx = 0.25_r_def*diff_basis_wx
    basis_wx(:,:) = 0.125_r_def

    ! Fields
    panel_id = (/ 1.0_r_def /)
    theta = (/ 300.0_r_def, 310.0_r_def /)

    ! Operators
    inv_m3(:,:,:) = 1.0_r_def/(dx*dy*dz)

    call eliminated_theta_q3t_code(cell,                    &
                                   nlayers,                 &
                                   ncell,                   &
                                   q3t,                     &
                                   theta,                   &
                                   ncell,                   &
                                   inv_m3,                  &
                                   x, y, z,                 &
                                   panel_id,                &
                                   ndf_w3,                  &
                                   basis_w3,                &
                                   ndf_wt, undf_wt, map_wt, &
                                   basis_wt,                &
                                   ndf_wx, undf_wx, map_wx, &
                                   basis_wx, diff_basis_wx, &
                                   ndf_p, undf_p, map_p,    &
                                   nqp, nqp, wgt, wgt)

    ! q3t = M3^-1 * < basis_w3, basis_wt/theta * detJ >
    answer = 0.0_r_def
    do df2 = 1,ndf_wt
      do df1 = 1, ndf_w3
        answer(df1,df2) = 1.0_r_def / (theta(2)+theta(1))
      end do
    end do
    @assertEqual(answer, q3t(:,:,1), tol)

  end subroutine test_all

end module eliminated_theta_q3t_kernel_mod_test
