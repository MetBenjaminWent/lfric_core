!-----------------------------------------------------------------------------
! (C) Crown copyright 2021 Met Office. All rights reserved.
! The file LICENCE, distributed with this code, contains details of the terms
! under which the code may be used.
!-----------------------------------------------------------------------------
!
!> @brief Provides constants used for limited area models.
!>
!> @details This module controls the set-up of various limited area model
!>          objects that do not change during a run. These objects are
!>          accessed from this module through appropriate 'get' functions.
!-------------------------------------------------------------------------------

module limited_area_constants_mod

  ! Infrastructure
  use base_mesh_config_mod,              only: geometry, geometry_spherical
  use constants_mod,                     only: i_def, r_def, str_def, str_short
  use field_mod,                         only: field_type
  use field_parent_mod,                  only: field_parent_type, write_interface
  use field_collection_mod,              only: field_collection_type
  use field_collection_iterator_mod,     only: field_collection_iterator_type, &
                                               field_collection_real_iterator_type
  use finite_element_config_mod,         only: coord_system, &
                                               coord_system_xyz
  use function_space_mod,                only: function_space_type
  use function_space_collection_mod,     only: function_space_collection
  use fs_continuity_mod,                 only: W2, W3, Wtheta
  use io_config_mod,                     only: subroutine_timers
  use log_mod,                           only: log_event, LOG_LEVEL_INFO, &
                                               LOG_LEVEL_ERROR
  use mesh_collection_mod,               only: mesh_collection
  use mesh_mod,                          only: mesh_type
  use timer_mod,                         only: timer
  use fs_continuity_mod,                 only: W2
  use mesh_mod,                          only: mesh_type
  use mesh_collection_mod,               only: mesh_collection
  use base_mesh_config_mod,              only: prime_mesh_name
  ! Configuration
  use boundaries_config_mod,             only: normal_only, lbc_method, &
                                               lbc_method_coordinate_based
  use finite_element_config_mod,         only: element_order

  ! Limited-area mask methods
  use limited_area_masks_alg_mod,        only: create_limited_area_mask,      &
                                               create_parallel_boundary_mask, &
                                               create_boundary_mask,          &
                                               create_blend_mask,             &
                                               create_lbc_mask,               &
                                               check_w2b_mask, &
                                               create_onion_layers
  use lfric_xios_write_mod,              only: write_field_edge, &
                                               write_field_face, &
                                               write_field_single_face

  implicit none

  private

  ! Variables private to this module that can only be accessed by public
  ! functions returning pointers to them

  ! Limited-area mask collection
  type(field_collection_type), target :: mask_collection

  ! Public functions to create and access the module contents

  public :: create_limited_area_constants
  public :: final_limited_area_constants
  public :: get_mask
  public :: get_boundary_mask
  public :: get_lbc_mask
  public :: get_blend_mask
  public :: get_onion_layers
  public :: write_masks

contains

  !> @brief Subroutine to create the limited area constants
  !> @param[in] chi             Coordinate field on primary mesh
  subroutine create_limited_area_constants(chi)
    implicit none

    ! Arguments
    type(field_type),      intent(in) :: chi(3)

    ! Internal variables
    type(function_space_type), pointer :: w2_fs     => null()
    type(function_space_type), pointer :: w3_fs     => null()
    type(function_space_type), pointer :: w3_2d_fs  => null()
    type(function_space_type), pointer :: wtheta_fs => null()
    type(field_type)                   :: w2parallel_mask
    type(field_type)                   :: w2perp_mask
    type(field_type)                   :: w2interior_mask
    type(field_type), pointer          :: field_ptr => null()
    type(field_type), pointer          :: onion_layers => null()
    type(field_type), pointer          :: w2boundary_mask => null()
    type(field_type), pointer          :: w2_mask => null()

    procedure(write_interface), pointer :: tmp_write_ptr => null()

    integer(kind=i_def)      :: primary_mesh_id, twod_mesh_id
    character(len=str_short) :: primary_suffix, twod_suffix, suffix
    type(mesh_type), pointer :: primary_mesh => null()
    type(mesh_type), pointer :: twod_mesh => null()

    if ( subroutine_timers ) call timer('limited_area_constants_alg')
    call log_event( "Gungho: creating limited_area_constants", LOG_LEVEL_INFO )

    call mask_collection%initialise(name='mask_collection')

    !===================== Start loop and creation of fields =======================!

    ! Loop through meshes to find the ones we're interested in, i.e. primary and twod
    ! TODO: #2790 should change this structure to avoid looping through meshes
    primary_mesh => mesh_collection%get_mesh( prime_mesh_name )
    twod_mesh    => mesh_collection%get_mesh( trim(prime_mesh_name)//'_2d' )

    primary_mesh_id = primary_mesh%get_id()
    write(suffix, '(I8)') primary_mesh_id
    primary_suffix='_'//trim(adjustl(suffix))
    twod_mesh_id = twod_mesh%get_id()
    write(suffix, '(A,I8)') '_', twod_mesh_id
    twod_suffix='_'//trim(adjustl(suffix))

    !===========  Create function spaces  ===================!

    w2_fs     => function_space_collection%get_fs( primary_mesh, element_order, W2 )
    w3_fs     => function_space_collection%get_fs( primary_mesh, element_order, W3 )
    w3_2d_fs  => function_space_collection%get_fs( twod_mesh, 0, W3 )
    wtheta_fs => function_space_collection%get_fs( primary_mesh, element_order, Wtheta )

    ! Create the fields
    tmp_write_ptr => write_field_face
    call create_mask_field('w3_mask'//primary_suffix, w3_fs,  tmp_write_ptr)
    call create_mask_field('w3lbc_mask'//primary_suffix, w3_fs,  tmp_write_ptr)
    call create_mask_field('w3blend_mask'//primary_suffix, w3_fs,  tmp_write_ptr)

    call create_mask_field('wtheta_mask'//primary_suffix, wtheta_fs,  tmp_write_ptr)
    call create_mask_field('wthetalbc_mask'//primary_suffix, wtheta_fs,  tmp_write_ptr)
    call create_mask_field('wthetablend_mask'//primary_suffix, wtheta_fs,  tmp_write_ptr)

    tmp_write_ptr => write_field_edge
    call create_mask_field('w2_mask'//primary_suffix, w2_fs,  tmp_write_ptr)
    call create_mask_field('w2lbc_mask'//primary_suffix, w2_fs,  tmp_write_ptr)
    call create_mask_field('w2blend_mask'//primary_suffix, w2_fs,  tmp_write_ptr)
    call create_mask_field('w2boundary_mask'//primary_suffix, w2_fs,  tmp_write_ptr)

    tmp_write_ptr => write_field_single_face
    call create_mask_field('onion_layers', w3_2d_fs,  tmp_write_ptr)

    ! Things referred to often (more than once)
    onion_layers => mask_collection%get_field('onion_layers')
    w2boundary_mask => mask_collection%get_field('w2boundary_mask'//primary_suffix)
    w2_mask => mask_collection%get_field('w2_mask'//primary_suffix)

    ! Create the W2 masks by combining different masks together
    call w2perp_mask%initialise( vector_space = w2_fs )
    call w2parallel_mask%initialise( vector_space = w2_fs )
    call w2interior_mask%initialise( vector_space = w2_fs )

    call create_onion_layers( onion_layers )

    if (normal_only) then
      call log_event( "Using w2 dofs on boundary for LBC", &
           LOG_LEVEL_INFO )
      call create_boundary_mask( w2boundary_mask, onion_layers, chi )
      call create_limited_area_mask( w2_mask, onion_layers, chi )
    else
      call log_event( "Using w2 dofs on boundary and tangential 1 cell in", &
           LOG_LEVEL_INFO )
      call create_boundary_mask( w2perp_mask, onion_layers, chi )
      call create_parallel_boundary_mask ( w2parallel_mask, chi )
      call create_limited_area_mask( w2interior_mask, onion_layers, chi )

      call invoke( &
         ! Add the W2parallel and W2perp masks together
         X_plus_Y ( w2boundary_mask,  w2perp_mask, w2parallel_mask ), &
         ! Subtract the W2parallel mask from the W2interior_mask
         X_minus_Y( w2_mask, w2interior_mask, w2parallel_mask ) )
    end if


    field_ptr => mask_collection%get_field('w3_mask'//primary_suffix)
    call create_limited_area_mask( field_ptr, onion_layers, chi )
    field_ptr => mask_collection%get_field('wtheta_mask'//primary_suffix)
    call create_limited_area_mask( field_ptr, onion_layers, chi )
    field_ptr => mask_collection%get_field('w2lbc_mask'//primary_suffix)
    call create_lbc_mask( field_ptr, onion_layers, chi )
    field_ptr => mask_collection%get_field('w3lbc_mask'//primary_suffix)
    call create_lbc_mask( field_ptr, onion_layers, chi )
    field_ptr => mask_collection%get_field('wthetalbc_mask'//primary_suffix)
    call create_lbc_mask( field_ptr, onion_layers, chi )
    field_ptr => mask_collection%get_field('w2blend_mask'//primary_suffix)
    call create_blend_mask( field_ptr, onion_layers, chi )
    field_ptr => mask_collection%get_field('w3blend_mask'//primary_suffix)
    call create_blend_mask( field_ptr, onion_layers, chi )
    field_ptr => mask_collection%get_field('wthetablend_mask'//primary_suffix)
    call create_blend_mask( field_ptr, onion_layers, chi )

    ! Check that the W2 boundary mask has the correct number of dofs
    ! if we're using the coordinate_based method
    if ( lbc_method == lbc_method_coordinate_based )then
      call check_w2b_mask( w2boundary_mask )
    end if

    call list_mask_fields()

    nullify( w2_fs  )
    nullify( w3_2d_fs  )
    nullify( w3_fs  )
    nullify( wtheta_fs )

    call log_event( "Gungho: created limited_area_constants", LOG_LEVEL_INFO )
    if ( subroutine_timers ) call timer('limited_area_constants_alg')

  end subroutine create_limited_area_constants

  subroutine create_mask_field(name, vector_space, write_behaviour)

    implicit none

    character(*), intent(in)                       :: name
    type(function_space_type), pointer, intent(in) :: vector_space
    procedure(write_interface), pointer, intent(in) :: write_behaviour
    type(field_type) :: mask

    call mask%initialise( vector_space = vector_space, name=trim(name) )
    call mask%set_write_behaviour(write_behaviour)
    call mask_collection%add_field( mask)

  end subroutine create_mask_field

  subroutine list_mask_fields()

    implicit none

    type( field_type ), pointer :: field_ptr  => null()
    type(field_collection_real_iterator_type)  :: iterator
    character(str_def) :: name

    call log_event( "Mask Collection fields:", LOG_LEVEL_INFO )
    ! write out each mask in the collection
    call iterator%initialise(mask_collection)
    do
      if ( .not.iterator%has_next() ) exit
      field_ptr => iterator%next()
      name = trim(adjustl( field_ptr%get_name() ))
      call log_event( name, LOG_LEVEL_INFO )
    end do
    field_ptr => null()

  end subroutine list_mask_fields


  subroutine write_masks()
    use diagnostic_alg_mod,            only: extract_w2h_diagnostic_alg
    use lfric_xios_write_mod,          only: write_field_face, &
                                             write_field_edge
    use field_parent_mod,              only: write_interface
    implicit none

    type( field_type ), pointer :: field_ptr  => null()
    type(field_collection_real_iterator_type)  :: iterator
    character(str_def) :: name
    type(function_space_type), pointer :: fs => null()

    type(field_type)                :: h_component, v_component

    procedure(write_interface), pointer  :: h_comp_write_ptr => null()
    procedure(write_interface), pointer  :: v_comp_write_ptr => null()

    ! write out each mask in the collection
    call iterator%initialise(mask_collection)
    do
      if ( .not.iterator%has_next() ) exit

      field_ptr => iterator%next()
      name = trim(adjustl( field_ptr%get_name() ))
      fs => field_ptr%get_function_space()

      select case(fs%which())
      case (W2)
        ! XIOS output for W2 is 2D, so the output is
        ! for the horiztonal component on 'edges' and
        ! vertical component on 'faces'

        call extract_w2h_diagnostic_alg( h_component, v_component, &
                                         field_ptr )
        v_comp_write_ptr => write_field_face
        call v_component%set_write_behaviour(v_comp_write_ptr)
        h_comp_write_ptr => write_field_edge
        call h_component%set_write_behaviour(h_comp_write_ptr)
        call h_component%write_field( "h_"//trim(name) )
        call v_component%write_field( "v_"//trim(name) )
      case default
        call field_ptr%write_field(name)
      end select
    end do
    field_ptr => null()

  end subroutine write_masks

  !> @brief  Returns pointer to the interior mask
  !> @param[in] space The function space of the interior mask
  !> @param[in] mesh_id The ID of the mesh to get the object for
  !> @return The interior mask field
  function get_mask(space, mesh_id) result(mask_ptr)
    implicit none
    integer(kind=i_def), intent(in) :: mesh_id
    integer(kind=i_def), intent(in) :: space
    type(field_type),       pointer :: mask_ptr
    character(len=str_short)        :: mesh_number
    character(len=str_def)          :: field_name

    write(mesh_number, '(I8)') mesh_id

    select case (space)
      case (W2)
        field_name = trim('w2_mask_') // adjustl(mesh_number)
        mask_ptr => mask_collection%get_field(field_name)
      case (W3)
        field_name = trim('w3_mask_') // adjustl(mesh_number)
        mask_ptr => mask_collection%get_field(field_name)
      case (Wtheta)
        field_name = trim('wtheta_mask_') // adjustl(mesh_number)
        mask_ptr => mask_collection%get_field(field_name)
      case default
        mask_ptr => null()
        call log_event( "Mask not available on requested space", &
          LOG_LEVEL_ERROR)
    end select

  end function get_mask

  !> @brief  Returns pointer to the boundary mask
  !> @param[in] space The function space of the boundary mask
  !> @param[in] mesh_id The ID of the mesh to get the object for
  !> @return The boundary mask field
  function get_boundary_mask(space, mesh_id) result(mask_ptr)
    implicit none
    integer(kind=i_def), intent(in) :: mesh_id
    integer(kind=i_def), intent(in) :: space
    type(field_type),       pointer :: mask_ptr
    character(len=str_short)        :: mesh_number
    character(len=str_def)          :: field_name

    write(mesh_number, '(I8)') mesh_id

    select case (space)
      case (W2)
        field_name = trim('w2boundary_mask_') // adjustl(mesh_number)
        mask_ptr => mask_collection%get_field(field_name)
      case default
        mask_ptr => null()
        call log_event( "Boundary mask not available on requested space", &
          LOG_LEVEL_ERROR)
    end select

  end function get_boundary_mask

  !> @brief  Returns pointer to the LBC mask
  !> @param[in] space The function space of the LBC mask
  !> @param[in] mesh_id The ID of the mesh to get the object for
  !> @return The LBC mask field
  function get_lbc_mask(space, mesh_id) result(mask_ptr)
    implicit none
    integer(kind=i_def), intent(in) :: mesh_id
    integer(kind=i_def), intent(in) :: space
    type(field_type),       pointer :: mask_ptr
    character(len=str_short)        :: mesh_number
    character(len=str_def)          :: field_name

    write(mesh_number, '(I8)') mesh_id

    select case (space)
      case (W2)
        field_name = trim('w2lbc_mask_') // adjustl(mesh_number)
        mask_ptr => mask_collection%get_field(field_name)
      case (W3)
        field_name = trim('w3lbc_mask_') // adjustl(mesh_number)
        mask_ptr => mask_collection%get_field(field_name)
      case (Wtheta)
        field_name = trim('wthetalbc_mask_') // adjustl(mesh_number)
        mask_ptr => mask_collection%get_field(field_name)
      case default
        mask_ptr => null()
        call log_event( "Mask not available on requested space", &
          LOG_LEVEL_ERROR)
    end select

  end function get_lbc_mask

  !> @brief  Returns pointer to the onion_layer mask
  !> @return The onion_layer mask
  function get_onion_layers() result(mask_ptr)
    implicit none
    type(field_type),       pointer :: mask_ptr

    mask_ptr => mask_collection%get_field('onion_layers')

  end function get_onion_layers

  !> @brief  Returns pointer to the blend mask
  !> @param[in] space The function space of the blend mask
  !> @param[in] mesh_id The ID of the mesh to get the object for
  !> @return The blend mask field
  function get_blend_mask(space, mesh_id) result(mask_ptr)
    implicit none
    integer(kind=i_def), intent(in) :: mesh_id
    integer(kind=i_def), intent(in) :: space
    type(field_type),       pointer :: mask_ptr
    character(len=str_short)        :: mesh_number
    character(len=str_def)          :: field_name

    write(mesh_number, '(I8)') mesh_id

    select case (space)
    case (W2)
      field_name = trim('w2blend_mask_') // adjustl(mesh_number)
      mask_ptr => mask_collection%get_field(field_name)
    case (W3)
      field_name = trim('w3blend_mask_') // adjustl(mesh_number)
      mask_ptr => mask_collection%get_field(field_name)
    case (Wtheta)
      field_name = trim('wthetablend_mask_') // adjustl(mesh_number)
      mask_ptr => mask_collection%get_field(field_name)
    case default
      mask_ptr => null()
      call log_event( "Blend mask not available on requested space", &
        LOG_LEVEL_ERROR)
    end select

  end function get_blend_mask

  !> @brief Explicitly reclaim memory from module scope variables
  !
  subroutine final_limited_area_constants()

    implicit none

    call mask_collection%clear()

  end subroutine final_limited_area_constants

end module limited_area_constants_mod
