!-----------------------------------------------------------------------------
! (C) Crown copyright 2018 Met Office. All rights reserved.
! The file LICENCE, distributed with this code, contains details of the terms
! under which the code may be used.
!-----------------------------------------------------------------------------

!> Test the field collection object
!>
module field_collection_mod_test

    use constants_mod,                 only : i_def, r_def, l_def
    use function_space_mod,            only : function_space_type
    use function_space_collection_mod, only : function_space_collection_type, &
                                              function_space_collection
    use mesh_collection_mod,           only : mesh_collection_type, &
                                              mesh_collection
    use halo_routing_collection_mod,   only : halo_routing_collection_type, &
                                              halo_routing_collection
    use field_mod,                     only : field_type,field_proxy_type
    use field_parent_mod,              only : field_parent_type
    use integer_field_mod,             only : integer_field_type, &
                                              integer_field_proxy_type
    use field_collection_mod,          only : field_collection_type, &
                                              field_collection_iterator_type, &
                                              field_collection_real_iterator_type
    use fs_continuity_mod,             only : W0, W2
    use pure_abstract_field_mod,       only : pure_abstract_field_type
    use yaxt,                          only : xt_initialize, xt_finalize
    use mpi_mod,                       only : store_comm, clear_comm
    use pFUnit_Mod

  implicit none

  private
  public :: test_all
  public :: test_assignment

  @TestCase
  type, extends(MPITestCase), public :: field_collection_test_type
    private
    type(function_space_type), pointer :: w0_fs => null()
    type(function_space_type), pointer :: w2_fs => null()
  contains
    procedure setUp
    procedure tearDown
    procedure test_all
    procedure test_assignment
  end type field_collection_test_type

  integer(i_def), parameter :: element_order = 0

contains

  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  subroutine setUp( this )

    use mesh_mod, only : PLANE_BI_PERIODIC

    implicit none

    class(field_collection_test_type), intent(inout) :: this
    integer(i_def) :: mesh_id

    ! Initialise YAXT
    call xt_initialize(this%getMpiCommunicator())
    !Store the MPI communicator for later use
    call store_comm(this%getMpiCommunicator())

    ! Create top level mesh collection
    mesh_collection = mesh_collection_type()
    ! Create top level function space collection
    function_space_collection = function_space_collection_type()
    ! Create top level halo_routing collection
    halo_routing_collection = halo_routing_collection_type()

    ! Dummy mesh mod has 9 cells, 3 layers and is uniform in vertical
    mesh_id = mesh_collection%add_unit_test_mesh( PLANE_BI_PERIODIC )


    this%w0_fs => function_space_collection%get_fs( mesh_id, &
                                                    element_order, &
                                                    W0 )

    this%w2_fs => function_space_collection%get_fs( mesh_id, &
                                                    element_order, &
                                                    W2 )

  end subroutine setUp

  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  subroutine tearDown( this )

    implicit none

    class(field_collection_test_type), intent(inout) :: this

    call function_space_collection%clear()
    call mesh_collection%clear()

    ! Finalise YAXT
    call xt_finalize()
    ! Clear the stored MPI communicator
    call clear_comm()

  end subroutine tearDown

  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  @Test( npes=[1] )
  subroutine test_all( this )

    implicit none

    class(field_collection_test_type), intent(inout) :: this
    class(pure_abstract_field_type), pointer :: field_ptr
    type(field_type) :: test_field1
    type(field_proxy_type) :: test_field1_p
    type(integer_field_type) :: test_field2
    type(integer_field_proxy_type) :: test_field2_p
    type(field_type), pointer :: returned_field1
    type(field_type), pointer :: returned_field2
    type(integer_field_type), pointer :: returned_field3
    type(field_proxy_type) :: returned_field1_p
    type(field_proxy_type) :: returned_field2_p
    type(integer_field_proxy_type) :: returned_field3_p
    type(field_collection_type) :: test_field_collection1
    type(field_collection_type) :: test_field_collection2
    real(r_def), parameter :: tol = 1.0e-6_r_def
    type(field_collection_iterator_type) :: iter
    type(field_collection_real_iterator_type) :: iter_real
    class(field_parent_type), pointer :: fld => null()
    integer(i_def) :: length, i
    logical(l_def) :: exists

    ! Create a field object with the name 'test_field1'
    ! and put 99.0 in the first dof
    call test_field1%initialise( this%w0_fs, name='test_field1' )
    test_field1_p = test_field1%get_proxy()
    test_field1_p%data(1)=99.0

    ! Create an integer field object with the name 'test_field2'
    ! and put 33 in the first dof
    call test_field2%initialise( this%w0_fs, name='test_field2' )
    test_field2_p = test_field2%get_proxy()
    test_field2_p%data(1)=33

    ! Create a field_collection and put test_field1 and test_field2 in it
    test_field_collection1 = field_collection_type()
    call test_field_collection1%add_field(test_field1)
    call test_field_collection1%add_field(test_field2)

    ! Check that test_field1 exists in field_collection
    exists = test_field_collection1%field_exists('test_field1')
    @assertTrue(exists)

    ! Extract the field called 'test_field1' into returned_field1
    returned_field1 => test_field_collection1%get_field('test_field1')
    returned_field1_p = returned_field1%get_proxy()

    ! Check that test_field2 has 99.0 in the first dof
    @assertEqual(99.0, returned_field1_p%data(1), tol)

    ! Extract the field called 'test_field2' into returned_field3
    returned_field3 => test_field_collection1%get_integer_field('test_field2')
    returned_field3_p = returned_field3%get_proxy()

    ! Check that test_field2 has 33 in the first dof
    @assertEqual(33, returned_field3_p%data(1))

    ! Create a second field_collection and put a reference to the field
    ! that is stored in the first field_collection into it
    test_field_collection2 = field_collection_type()
    field_ptr => returned_field1
    call test_field_collection2%add_reference_to_field(field_ptr)

    ! Change the data in the original field
    returned_field1_p%data(1)=999.0

    ! Check that the reference to that field has been updated
    returned_field2 => test_field_collection2%get_field('test_field1')
    returned_field2_p = returned_field2%get_proxy()
    @assertEqual(999.0, returned_field2_p%data(1), tol)

    ! Check we can remove a field from the field collection
    call test_field_collection1%remove_field("test_field1")
    length=test_field_collection1%get_length()
    @assertEqual(1, length)

    ! Check that test_field1 no longer exists in field_collection
    exists = test_field_collection1%field_exists('test_field1')
    @assertFalse(exists)

    ! Check we can add the field back into the collection
    call test_field_collection1%add_field(test_field1)
    returned_field1 => test_field_collection1%get_field('test_field1')
    returned_field1_p = returned_field1%get_proxy()
    @assertEqual(99.0, returned_field1_p%data(1), tol)

    ! Check we can iterate over a collection
    ! At this point, test_field_collection1 should contain:
    ! 1. An integer field with 33 as the first data item
    ! 2. A real field with a first data item of 99.0
    !    - so check for that:
    iter=test_field_collection1%get_iterator()
    do i=1,10
      if(.not.iter%has_next())exit
      fld=>iter%next()
      select type(fld)
        type is (field_type)
          @assertEqual(2, i)
          test_field1_p = fld%get_proxy()
          @assertEqual(99.0, returned_field1_p%data(1), tol)
        type is (integer_field_type)
          @assertEqual(1, i)
          returned_field3_p = fld%get_proxy()
          @assertEqual(33, returned_field3_p%data(1))
      end select
    end do
    ! Test that there were only two items in the collection (so the iteration
    ! loop exited on i==3)
    @assertEqual(3, i)

    ! Check we can iterate over just the real fields in a collection
    ! At this point, test_field_collection1 should contain:
    ! 1. An integer field with 33 as the first data item
    ! 2. A real field with a first data item of 99.0
    !    - so check the real field iterator sees just the real field:
    iter_real=test_field_collection1%get_real_iterator()
    do i=1,10
      if(.not.iter_real%has_next())exit
      returned_field1=>iter_real%next()
      returned_field1_p = returned_field1%get_proxy()
      @assertEqual(99.0, returned_field1_p%data(1), tol)
    end do
    ! Test that there was only one real field in the collection (so the
    ! iteration loop exited on i==2)
    @assertEqual(2, i)

  end subroutine test_all

  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  @Test( npes=[1] )
  subroutine test_assignment( self )

    implicit none

    class(field_collection_test_type), intent(inout) :: self
    class(pure_abstract_field_type), pointer         :: field_ptr
    type(field_type)                                 :: test_field1
    type(field_type), target                         :: test_field2
    type(field_type), pointer                        :: test_field2_ptr
    type(field_type), pointer                        :: returned_field
    type(field_proxy_type)                           :: proxy
    type(field_collection_type)                      :: f_collection
    type(field_collection_type)                      :: f_collection_copy

    real(r_def), parameter :: tol = 1.0e-6_r_def

    f_collection = field_collection_type("test_field_collection1")

    ! Assert the copy has preserved the name.
    f_collection_copy = f_collection
    @assertEqual(f_collection_copy % get_name(), "test_field_collection1")

    ! Create field with the name 'test_field1' and put 42.0 in the first dof.
    call test_field1%initialise( self % w0_fs, name='test_field1' )
    proxy = test_field1%get_proxy()
    proxy%data(1) = 42.0

    ! Check that adding a field added to one collection doesn't get result
    ! in it being added to the copy.
    call f_collection % add_field( test_field1 )
    @assertEqual(f_collection_copy % get_length(), 0)

    ! Copy the collection, and get hold of the copied field.
    f_collection_copy = f_collection
    returned_field => f_collection_copy % get_field( 'test_field1' )

    ! Check the name is the same, but that changing the data on one field
    ! doesn't change the data in the copy.
    @assertEqual(test_field1 % get_name(), returned_field % get_name())
    proxy = test_field1 % get_proxy()
    proxy%data(1) = 112.0
    proxy = returned_field % get_proxy()
    @assertEqual(42.0, proxy%data(1), tol)

    ! Make a pointer to another field, and add that as a reference to the collection.
    call test_field2%initialise( self % w2_fs, name='test_field2' )
    test_field2_ptr => test_field2
    field_ptr => test_field2_ptr
    call f_collection % add_reference_to_field( field_ptr )

    ! Test that the copied collection didn't grow when the original grew.
    @assertEqual(f_collection % get_length(), 2)
    @assertEqual(f_collection_copy % get_length(), 1)

    returned_field => f_collection % get_field('test_field2')
    ! Check that the field pointer has the same target after copy, but that
    ! the pointer object itself is different.
    f_collection_copy = f_collection
    returned_field => f_collection_copy % get_field('test_field2')
    @assertTrue(associated(test_field2_ptr, returned_field))

    ! Now if we nullify the original field pointer, we should still be able to use the
    ! pointer from the copied collection, and we should be pointing at the same data.
    nullify(test_field2_ptr)
    proxy = test_field2 % get_proxy()
    proxy%data(1) = 112.0
    proxy = returned_field % get_proxy()
    @assertEqual(112.0, proxy%data(1), tol)

  end subroutine test_assignment

end module field_collection_mod_test
