!-----------------------------------------------------------------------------
! Copyright (c) 2017,  Met Office, on behalf of HMSO and Queen's Printer
! For further details please refer to the file LICENCE which you
! should have received as part of this distribution.
!-----------------------------------------------------------------------------

!> Test the partition module
!>
module partition_mod_test

  use pfunit
  use constants_mod,              only: r_def, i_def, l_def, str_max_filename, &
                                        str_def
  use global_mesh_mod,            only: global_mesh_type
  use global_mesh_collection_mod, only: global_mesh_collection_type, &
                                        global_mesh_collection
  use lfric_mpi_mod,              only: global_mpi, &
                                        lfric_comm_type
  use partition_mod,              only: partition_type,                 &
                                        partitioner_planar,             &
                                        partitioner_cubedsphere,        &
                                        partitioner_cubedsphere_serial, &
                                        partitioner_interface
  use reference_element_mod,      only: reference_cube_type
  use ugrid_mesh_data_mod,        only: ugrid_mesh_data_type
  use panel_decomposition_mod,    only: custom_decomposition_type

  implicit none

  private
  public :: test_partition_CubedSphere, test_partition_BiPeriodic, &
            test_partition_planar, test_partition_trench_x,        &
            test_partition_trench_y
  !
  ! pFUnit relies on symbol spillage
  !
  public :: MPITestCase, MPITestParameter

  @testCase
  type, public, extends( MPITestCase ) :: partition_test_type
    private
    integer :: dummy ! This is here only so procedures which do not use "this"
                     ! have something they can hit.
    type(reference_cube_type), pointer :: reference_element => null()
  contains
    procedure :: setUp
    procedure :: tearDown
  end type partition_test_type

  character(str_def), parameter :: mesh_name = 'unit_test'

contains

  subroutine setUp( this )

    implicit none

    class( partition_test_type ), intent( inout ) :: this
    type(lfric_comm_type) :: lfric_comm

    call lfric_comm%set_comm_mpi_val(this%getMpiCommunicator())

    allocate( this%reference_element, source=reference_cube_type() )

    global_mesh_collection = global_mesh_collection_type()

    !Store the MPI communicator for later use
    call global_mpi%initialise(lfric_comm)

  end subroutine setUp

  subroutine tearDown( this )

    implicit none

    class( partition_test_type ), intent( inout ) :: this

    deallocate( this%reference_element )

    call global_mesh_collection%clear()

    ! Clear the stored MPI communicator
     call global_mpi%finalise()

  end subroutine teardown

  !> Test partition module functionality
  !>
  @Test(npes=[1, 3, 4] )
  subroutine test_partition_BiPeriodic( this )

    implicit none

    class( partition_test_type ), intent( inout ) :: this

    type(ugrid_mesh_data_type)      :: ugrid_mesh_data
    type(global_mesh_type), pointer :: global_mesh_ptr => null()
    type(global_mesh_type)          :: global_mesh
    type(partition_type)            :: partition

    procedure (partitioner_interface), pointer :: partitioner_ptr => null()
    type(custom_decomposition_type) :: decomposition

    integer :: xproc
    integer :: yproc
    integer :: local_rank
    integer :: total_ranks
    integer :: max_stencil_depth

    integer :: num_cells_in_layer
    integer :: inner_depth
    integer :: halo_depth
    integer :: num_cells_inner
    integer :: last_inner_cell
    integer :: num_cells_edge
    integer :: last_edge_cell
    integer :: num_cells_halo
    integer :: last_halo_cell
    integer(i_def) :: num_cells_ghost

    integer(i_def) :: global_mesh_id
    integer(i_def) :: num_processes

    logical(l_def) :: generate_inner_halos

    character(len = str_max_filename) :: filename

    num_processes = this%context%getNumProcesses()
    select case (num_processes)
      case (1)
        xproc = 1
        yproc = 1
      case (3)
        xproc = 3
        yproc = 1
      case (4)
        xproc = 2
        yproc = 2
    end select

    local_rank = this%getProcessRank()
    total_ranks = this%getNumProcesses()
    max_stencil_depth = 2

    generate_inner_halos = .true.

    filename = 'data/mesh_BiP8x8-750x250.nc'
    call ugrid_mesh_data%read_from_file(trim(filename), mesh_name)
    global_mesh = global_mesh_type( ugrid_mesh_data )
    call ugrid_mesh_data%clear()
    global_mesh_id = global_mesh%get_id()
    call global_mesh_collection%add_new_global_mesh( global_mesh )
    global_mesh_ptr => global_mesh_collection%get_global_mesh( global_mesh_id )

    partitioner_ptr => partitioner_planar
    decomposition = custom_decomposition_type(xproc, yproc)
    !
    ! Generate the partition
    partition = partition_type( global_mesh_ptr,       &
                                partitioner_ptr,       &
                                decomposition,         &
                                max_stencil_depth,     &
                                generate_inner_halos,  &
                                local_rank,            &
                                total_ranks )

    ! Test functionality of the partition object we've just created on 1, 3
    ! and 4 processes
    select case (num_processes)

      case (1)
! Testing over 1 (8x8) partition. All cells are owned - so no halo/ghost cells

        num_cells_in_layer = partition%get_num_cells_in_layer()
        @assertEqual( 64, num_cells_in_layer )

        inner_depth = partition%get_inner_depth()
        @assertEqual( 2, inner_depth )

        num_cells_inner = partition%get_num_cells_inner(1)
        @assertEqual( 20, num_cells_inner )

        last_inner_cell = partition%get_last_inner_cell(1)
        @assertEqual( 36, last_inner_cell )

        num_cells_edge = partition%get_num_cells_edge()
        @assertEqual( 28, num_cells_edge )

        last_edge_cell = partition%get_last_edge_cell()
        @assertEqual( 64, last_edge_cell )

        halo_depth = partition%get_halo_depth()
        @assertEqual( 2, halo_depth )

        num_cells_halo = partition%get_num_cells_halo(1)
        @assertEqual( 0, num_cells_halo )

        last_halo_cell = partition%get_last_halo_cell(1)
        @assertEqual( 64, last_halo_cell )

        num_cells_ghost = partition%get_num_cells_ghost()
        @assertEqual( 0, num_cells_ghost )

      case (3)
! Testing over 3 partitions will produce uneven partitions, PE1 and PE2 will be
! the same (3x8), but PE0 will be slightly smaller (2x8)

! Start with quantities that will be the same for all PEs
        inner_depth = partition%get_inner_depth()
        @assertEqual( 2, inner_depth )

        halo_depth = partition%get_halo_depth()
        @assertEqual( 2, halo_depth )

        num_cells_halo = partition%get_num_cells_halo(1)
        @assertEqual( 16, num_cells_halo )

! Now check quantities that differ between PE0 and PE1/2
        select case (local_rank)
          case(0)
            num_cells_in_layer = partition%get_num_cells_in_layer()
            @assertEqual( 48, num_cells_in_layer )

            num_cells_inner = partition%get_num_cells_inner(1)
            @assertEqual( 0, num_cells_inner )

            last_inner_cell = partition%get_last_inner_cell(1)
            @assertEqual( 0, last_inner_cell )

            num_cells_edge = partition%get_num_cells_edge()
            @assertEqual( 16, num_cells_edge )

            last_edge_cell = partition%get_last_edge_cell()
            @assertEqual( 16, last_edge_cell )

            last_halo_cell = partition%get_last_halo_cell(1)
            @assertEqual( 32, last_halo_cell )

            num_cells_ghost = partition%get_num_cells_ghost()
            @assertEqual( 16, num_cells_ghost )
          case(1, 2)
            num_cells_in_layer = partition%get_num_cells_in_layer()
            @assertEqual( 56, num_cells_in_layer )

            num_cells_inner = partition%get_num_cells_inner(1)
            @assertEqual( 6, num_cells_inner )

            last_inner_cell = partition%get_last_inner_cell(1)
            @assertEqual( 6, last_inner_cell )

            num_cells_edge = partition%get_num_cells_edge()
            @assertEqual( 18, num_cells_edge )

            last_edge_cell = partition%get_last_edge_cell()
            @assertEqual( 24, last_edge_cell )

            num_cells_halo = partition%get_num_cells_halo(1)
            @assertEqual( 16, num_cells_halo )

            last_halo_cell = partition%get_last_halo_cell(1)
            @assertEqual( 40, last_halo_cell )

            num_cells_ghost = partition%get_num_cells_ghost()
            @assertEqual( 8, num_cells_ghost )
        end select

      case (4)
! Testing over four similar (4x4) partitions

        num_cells_in_layer = partition%get_num_cells_in_layer()
        @assertEqual( 64, num_cells_in_layer )

        inner_depth = partition%get_inner_depth()
        @assertEqual( 2, inner_depth )

        num_cells_inner = partition%get_num_cells_inner(1)
        @assertEqual( 4, num_cells_inner )

        last_inner_cell = partition%get_last_inner_cell(1)
        @assertEqual( 4, last_inner_cell )

        num_cells_edge = partition%get_num_cells_edge()
        @assertEqual( 12, num_cells_edge )

        last_edge_cell = partition%get_last_edge_cell()
        @assertEqual( 16, last_edge_cell )

        halo_depth = partition%get_halo_depth()
        @assertEqual( 2, halo_depth )

        num_cells_halo = partition%get_num_cells_halo(1)
        @assertEqual( 20, num_cells_halo )

        last_halo_cell = partition%get_last_halo_cell(1)
        @assertEqual( 36, last_halo_cell )

        num_cells_ghost = partition%get_num_cells_ghost()
        @assertEqual( 0, num_cells_ghost )

    end select

  end subroutine test_partition_BiPeriodic

  @Test(npes=[1, 3, 4] )
  subroutine test_partition_planar( this )

    implicit none

    class( partition_test_type ), intent( inout ) :: this

    type(ugrid_mesh_data_type)      :: ugrid_mesh_data
    type(global_mesh_type), pointer :: global_mesh_ptr => null()
    type(global_mesh_type)          :: global_mesh
    type(partition_type)            :: partition

    procedure (partitioner_interface), pointer :: partitioner_ptr => null()
    type(custom_decomposition_type) :: decomposition

    integer :: xproc
    integer :: yproc
    integer :: local_rank
    integer :: total_ranks
    integer :: max_stencil_depth

    integer :: num_cells_in_layer
    integer :: inner_depth
    integer :: halo_depth
    integer :: num_cells_inner
    integer :: last_inner_cell
    integer :: num_cells_edge
    integer :: last_edge_cell
    integer :: num_cells_halo
    integer :: last_halo_cell
    integer(i_def) :: num_cells_ghost

    integer(i_def) :: global_mesh_id
    integer(i_def) :: num_processes

    logical(l_def) :: generate_inner_halos

    character(len = str_max_filename) :: filename

    num_processes = this%context%getNumProcesses()
    select case (num_processes)
      case (1)
        xproc = 1
        yproc = 1
      case (3)
        xproc = 3
        yproc = 1
      case (4)
        xproc = 2
        yproc = 2
    end select

    local_rank = this%getProcessRank()
    total_ranks = this%getNumProcesses()
    max_stencil_depth = 2

    generate_inner_halos = .true.

    filename = 'data/mesh_planar.nc'

    call ugrid_mesh_data%read_from_file(trim(filename), mesh_name)
    global_mesh = global_mesh_type( ugrid_mesh_data )
    call ugrid_mesh_data%clear()
    global_mesh_id = global_mesh%get_id()
    call global_mesh_collection%add_new_global_mesh( global_mesh )

    global_mesh_ptr => global_mesh_collection%get_global_mesh( global_mesh_id )

    partitioner_ptr => partitioner_planar
    decomposition = custom_decomposition_type(xproc, yproc)
    !
    ! Generate the partition
    partition = partition_type( global_mesh_ptr,       &
                                partitioner_ptr,       &
                                decomposition,         &
                                max_stencil_depth,     &
                                generate_inner_halos,  &
                                local_rank,            &
                                total_ranks )
    ! Test functionality of the partition object we've just created on 1, 3
    ! and 4 processes
    select case (num_processes)

      case (1)
! Testing over 1 (8x8) partition - no halo/ghost cells
        num_cells_in_layer = partition%get_num_cells_in_layer()
        @assertEqual( 64, num_cells_in_layer )

        inner_depth = partition%get_inner_depth()
        @assertEqual( 2, inner_depth )

        num_cells_inner = partition%get_num_cells_inner(1)
        @assertEqual( 20, num_cells_inner )

        last_inner_cell = partition%get_last_inner_cell(1)
        @assertEqual( 36, last_inner_cell )

        num_cells_edge = partition%get_num_cells_edge()
        @assertEqual( 28, num_cells_edge )

        last_edge_cell = partition%get_last_edge_cell()
        @assertEqual( 64, last_edge_cell )

        halo_depth = partition%get_halo_depth()
        @assertEqual( 2, halo_depth )

        num_cells_halo = partition%get_num_cells_halo(1)
        @assertEqual( 0, num_cells_halo )

        last_halo_cell = partition%get_last_halo_cell(1)
        @assertEqual( 64, last_halo_cell )

        num_cells_ghost = partition%get_num_cells_ghost()
        @assertEqual( 0, num_cells_ghost )

      case (3)
! Testing over 3 partitions will produce uneven partitions, PE1 and PE2 will be
! the same (3x8) (with different halos), but PE0 will be slightly smaller (2x8)

! Start with quantities that will be the same for all PEs
        inner_depth = partition%get_inner_depth()
        @assertEqual( 2, inner_depth )

        halo_depth = partition%get_halo_depth()
        @assertEqual( 2, halo_depth )

! Now check quantities that differ between the partitions
        select case (local_rank)
          case(0)
            num_cells_in_layer = partition%get_num_cells_in_layer()
            @assertEqual( 32, num_cells_in_layer )

            num_cells_inner = partition%get_num_cells_inner(1)
            @assertEqual( 0, num_cells_inner )

            last_inner_cell = partition%get_last_inner_cell(1)
            @assertEqual( 0, last_inner_cell )

            num_cells_edge = partition%get_num_cells_edge()
            @assertEqual( 16, num_cells_edge )

            last_edge_cell = partition%get_last_edge_cell()
            @assertEqual( 16, last_edge_cell )

            num_cells_halo = partition%get_num_cells_halo(1)
            @assertEqual( 8, num_cells_halo )

            last_halo_cell = partition%get_last_halo_cell(1)
            @assertEqual( 24, last_halo_cell )

            num_cells_ghost = partition%get_num_cells_ghost()
            @assertEqual( 8, num_cells_ghost )
          case(1)
            num_cells_in_layer = partition%get_num_cells_in_layer()
            @assertEqual( 56, num_cells_in_layer )

            num_cells_inner = partition%get_num_cells_inner(1)
            @assertEqual( 6, num_cells_inner )

            last_inner_cell = partition%get_last_inner_cell(1)
            @assertEqual( 6, last_inner_cell )

            num_cells_edge = partition%get_num_cells_edge()
            @assertEqual( 18, num_cells_edge )

            last_edge_cell = partition%get_last_edge_cell()
            @assertEqual( 24, last_edge_cell )

            num_cells_halo = partition%get_num_cells_halo(1)
            @assertEqual( 16, num_cells_halo )

            num_cells_halo = partition%get_num_cells_halo(1)
            @assertEqual( 16, num_cells_halo )

            last_halo_cell = partition%get_last_halo_cell(1)
            @assertEqual( 40, last_halo_cell )

            num_cells_ghost = partition%get_num_cells_ghost()
            @assertEqual( 8, num_cells_ghost )
          case(2)
            num_cells_in_layer = partition%get_num_cells_in_layer()
            @assertEqual( 40, num_cells_in_layer )

            num_cells_inner = partition%get_num_cells_inner(1)
            @assertEqual( 6, num_cells_inner )

            last_inner_cell = partition%get_last_inner_cell(1)
            @assertEqual( 6, last_inner_cell )

            num_cells_edge = partition%get_num_cells_edge()
            @assertEqual( 18, num_cells_edge )

            last_edge_cell = partition%get_last_edge_cell()
            @assertEqual( 24, last_edge_cell )

            num_cells_halo = partition%get_num_cells_halo(1)
            @assertEqual( 8, num_cells_halo )

            num_cells_halo = partition%get_num_cells_halo(1)
            @assertEqual( 8, num_cells_halo )

            last_halo_cell = partition%get_last_halo_cell(1)
            @assertEqual( 32, last_halo_cell )

            num_cells_ghost = partition%get_num_cells_ghost()
            @assertEqual( 8, num_cells_ghost )
        end select

      case (4)
! Testing over four similar (4x4) partitions

        num_cells_in_layer = partition%get_num_cells_in_layer()
        @assertEqual( 36, num_cells_in_layer )

        inner_depth = partition%get_inner_depth()
        @assertEqual( 2, inner_depth )

        num_cells_inner = partition%get_num_cells_inner(1)
        @assertEqual( 4, num_cells_inner )

        last_inner_cell = partition%get_last_inner_cell(1)
        @assertEqual( 4, last_inner_cell )

        num_cells_edge = partition%get_num_cells_edge()
        @assertEqual( 12, num_cells_edge )

        last_edge_cell = partition%get_last_edge_cell()
        @assertEqual( 16, last_edge_cell )

        halo_depth = partition%get_halo_depth()
        @assertEqual( 2, halo_depth )

        num_cells_halo = partition%get_num_cells_halo(1)
        @assertEqual( 9, num_cells_halo )

        last_halo_cell = partition%get_last_halo_cell(1)
        @assertEqual( 25, last_halo_cell )

        num_cells_ghost = partition%get_num_cells_ghost()
        @assertEqual( 13, num_cells_ghost )

    end select

  end subroutine test_partition_planar

  @Test(npes=[1, 3, 4] )
  subroutine test_partition_trench_x( this )

    implicit none

    class( partition_test_type ), intent( inout ) :: this

    type(ugrid_mesh_data_type)      :: ugrid_mesh_data
    type(global_mesh_type), pointer :: global_mesh_ptr => null()
    type(global_mesh_type)          :: global_mesh
    type(partition_type)            :: partition

    procedure (partitioner_interface), pointer :: partitioner_ptr => null()
    type(custom_decomposition_type) :: decomposition

    integer :: xproc
    integer :: yproc
    integer :: local_rank
    integer :: total_ranks
    integer :: max_stencil_depth

    integer :: num_cells_in_layer
    integer :: inner_depth
    integer :: halo_depth
    integer :: num_cells_inner
    integer :: last_inner_cell
    integer :: num_cells_edge
    integer :: last_edge_cell
    integer :: num_cells_halo
    integer :: last_halo_cell
    integer(i_def) :: num_cells_ghost

    integer(i_def) :: global_mesh_id
    integer(i_def) :: num_processes

    logical(l_def) :: generate_inner_halos

    character(len = str_max_filename) :: filename

    num_processes = this%context%getNumProcesses()
    select case (num_processes)
      case (1)
        xproc = 1
        yproc = 1
      case (3)
        xproc = 3
        yproc = 1
      case (4)
        xproc = 2
        yproc = 2
    end select

    local_rank = this%getProcessRank()
    total_ranks = this%getNumProcesses()
    max_stencil_depth = 2

    generate_inner_halos = .true.

    filename = 'data/mesh_trench_x.nc'

    call ugrid_mesh_data%read_from_file(trim(filename), mesh_name)
    global_mesh = global_mesh_type( ugrid_mesh_data )
    call ugrid_mesh_data%clear()
    global_mesh_id = global_mesh%get_id()
    call global_mesh_collection%add_new_global_mesh( global_mesh )

    global_mesh_ptr => global_mesh_collection%get_global_mesh( global_mesh_id )

    partitioner_ptr => partitioner_planar
    decomposition = custom_decomposition_type(xproc, yproc)
    !
    ! Generate the partition
    partition = partition_type( global_mesh_ptr,       &
                                partitioner_ptr,       &
                                decomposition,         &
                                max_stencil_depth,     &
                                generate_inner_halos,  &
                                local_rank,            &
                                total_ranks )
    ! Test functionality of the partition object we've just created on 1, 3
    ! and 4 processes
    select case (num_processes)

      case (1)
! Testing over 1 (8x8) partition. All cells are owned - so no halo/ghost cells

        num_cells_in_layer = partition%get_num_cells_in_layer()
        @assertEqual( 64, num_cells_in_layer )

        inner_depth = partition%get_inner_depth()
        @assertEqual( 2, inner_depth )

        num_cells_inner = partition%get_num_cells_inner(1)
        @assertEqual( 20, num_cells_inner )

        last_inner_cell = partition%get_last_inner_cell(1)
        @assertEqual( 36, last_inner_cell )

        num_cells_edge = partition%get_num_cells_edge()
        @assertEqual( 28, num_cells_edge )

        last_edge_cell = partition%get_last_edge_cell()
        @assertEqual( 64, last_edge_cell )

        halo_depth = partition%get_halo_depth()
        @assertEqual( 2, halo_depth )

        num_cells_halo = partition%get_num_cells_halo(1)
        @assertEqual( 0, num_cells_halo )

        last_halo_cell = partition%get_last_halo_cell(1)
        @assertEqual( 64, last_halo_cell )

        num_cells_ghost = partition%get_num_cells_ghost()
        @assertEqual( 0, num_cells_ghost )

      case (3)
! Testing over 3 partitions will produce uneven partitions, PE1 and PE2 will be
! the same (3x8), but PE0 will be slightly smaller (2x8)

! Start with quantities that will be the same for all PEs
        inner_depth = partition%get_inner_depth()
        @assertEqual( 2, inner_depth )

        halo_depth = partition%get_halo_depth()
        @assertEqual( 2, halo_depth )

        num_cells_halo = partition%get_num_cells_halo(1)
        @assertEqual( 16, num_cells_halo )

! Now check quantities that differ between PE0 and PE1/2
        select case (local_rank)
          case(0)
            num_cells_in_layer = partition%get_num_cells_in_layer()
            @assertEqual( 48, num_cells_in_layer )

            num_cells_inner = partition%get_num_cells_inner(1)
            @assertEqual( 0, num_cells_inner )

            last_inner_cell = partition%get_last_inner_cell(1)
            @assertEqual( 0, last_inner_cell )

            num_cells_edge = partition%get_num_cells_edge()
            @assertEqual( 16, num_cells_edge )

            last_edge_cell = partition%get_last_edge_cell()
            @assertEqual( 16, last_edge_cell )

            last_halo_cell = partition%get_last_halo_cell(1)
            @assertEqual( 32, last_halo_cell )

            num_cells_ghost = partition%get_num_cells_ghost()
            @assertEqual( 16, num_cells_ghost )
          case(1, 2)
            num_cells_in_layer = partition%get_num_cells_in_layer()
            @assertEqual( 56, num_cells_in_layer )

            num_cells_inner = partition%get_num_cells_inner(1)
            @assertEqual( 6, num_cells_inner )

            last_inner_cell = partition%get_last_inner_cell(1)
            @assertEqual( 6, last_inner_cell )

            num_cells_edge = partition%get_num_cells_edge()
            @assertEqual( 18, num_cells_edge )

            last_edge_cell = partition%get_last_edge_cell()
            @assertEqual( 24, last_edge_cell )

            num_cells_halo = partition%get_num_cells_halo(1)
            @assertEqual( 16, num_cells_halo )

            last_halo_cell = partition%get_last_halo_cell(1)
            @assertEqual( 40, last_halo_cell )

            num_cells_ghost = partition%get_num_cells_ghost()
            @assertEqual( 8, num_cells_ghost )
        end select

      case (4)
! Testing over four similar (4x4) partitions

        num_cells_in_layer = partition%get_num_cells_in_layer()
        @assertEqual( 48, num_cells_in_layer )

        inner_depth = partition%get_inner_depth()
        @assertEqual( 2, inner_depth )

        num_cells_inner = partition%get_num_cells_inner(1)
        @assertEqual( 4, num_cells_inner )

        last_inner_cell = partition%get_last_inner_cell(1)
        @assertEqual( 4, last_inner_cell )

        num_cells_edge = partition%get_num_cells_edge()
        @assertEqual( 12, num_cells_edge )

        last_edge_cell = partition%get_last_edge_cell()
        @assertEqual( 16, last_edge_cell )

        halo_depth = partition%get_halo_depth()
        @assertEqual( 2, halo_depth )

        num_cells_halo = partition%get_num_cells_halo(1)
        @assertEqual( 14, num_cells_halo )

        last_halo_cell = partition%get_last_halo_cell(1)
        @assertEqual( 30, last_halo_cell )

        num_cells_ghost = partition%get_num_cells_ghost()
        @assertEqual( 8, num_cells_ghost )

    end select

  end subroutine test_partition_trench_x

  @Test(npes=[1, 4] )
  subroutine test_partition_trench_y( this )

    implicit none

    class( partition_test_type ), intent( inout ) :: this

    type(ugrid_mesh_data_type)      :: ugrid_mesh_data
    type(global_mesh_type), pointer :: global_mesh_ptr => null()
    type(global_mesh_type)          :: global_mesh
    type(partition_type)            :: partition

    procedure (partitioner_interface), pointer :: partitioner_ptr => null()
    type(custom_decomposition_type) :: decomposition

    integer :: xproc
    integer :: yproc
    integer :: local_rank
    integer :: total_ranks
    integer :: max_stencil_depth

    integer :: num_cells_in_layer
    integer :: inner_depth
    integer :: halo_depth
    integer :: num_cells_inner
    integer :: last_inner_cell
    integer :: num_cells_edge
    integer :: last_edge_cell
    integer :: num_cells_halo
    integer :: last_halo_cell
    integer(i_def) :: num_cells_ghost

    integer(i_def) :: global_mesh_id
    integer(i_def) :: num_processes

    logical(l_def) :: generate_inner_halos

    character(len = str_max_filename) :: filename

    num_processes = this%context%getNumProcesses()
    select case (num_processes)
      case (1)
        xproc = 1
        yproc = 1
      case (3)
        xproc = 3
        yproc = 1
      case (4)
        xproc = 2
        yproc = 2
    end select

    local_rank = this%getProcessRank()
    total_ranks = this%getNumProcesses()
    max_stencil_depth = 2

    generate_inner_halos = .true.

    filename = 'data/mesh_trench_y.nc'

    call ugrid_mesh_data%read_from_file(trim(filename), mesh_name)
    global_mesh = global_mesh_type( ugrid_mesh_data )
    call ugrid_mesh_data%clear()
    global_mesh_id = global_mesh%get_id()
    call global_mesh_collection%add_new_global_mesh( global_mesh )

    global_mesh_ptr => global_mesh_collection%get_global_mesh( global_mesh_id )

    partitioner_ptr => partitioner_planar
    decomposition = custom_decomposition_type(xproc, yproc)
    !
    ! Generate the partition
    partition = partition_type( global_mesh_ptr,       &
                                partitioner_ptr,       &
                                decomposition,         &
                                max_stencil_depth,     &
                                generate_inner_halos,  &
                                local_rank,            &
                                total_ranks )
    ! Test functionality of the partition object we've just created on 1, 3
    ! and 4 processes
    select case (num_processes)

      case (1)
! Testing over 1 (8x8) partition - no halo/ghost cells

        num_cells_in_layer = partition%get_num_cells_in_layer()
        @assertEqual( 64, num_cells_in_layer )

        inner_depth = partition%get_inner_depth()
        @assertEqual( 2, inner_depth )

        num_cells_inner = partition%get_num_cells_inner(1)
        @assertEqual( 20, num_cells_inner )

        last_inner_cell = partition%get_last_inner_cell(1)
        @assertEqual( 36, last_inner_cell )

        num_cells_edge = partition%get_num_cells_edge()
        @assertEqual( 28, num_cells_edge )

        last_edge_cell = partition%get_last_edge_cell()
        @assertEqual( 64, last_edge_cell )

        halo_depth = partition%get_halo_depth()
        @assertEqual( 2, halo_depth )

        num_cells_halo = partition%get_num_cells_halo(1)
        @assertEqual( 0, num_cells_halo )

        last_halo_cell = partition%get_last_halo_cell(1)
        @assertEqual( 64, last_halo_cell )

        num_cells_ghost = partition%get_num_cells_ghost()
        @assertEqual( 0, num_cells_ghost )

      case (3)
! Testing over 3 partitions will produce uneven partitions, PE1 and PE2 will be
! the same (3x8) (with different halos), but PE0 will be slightly smaller (2x8)

! Start with quantities that will be the same for all PEs
        inner_depth = partition%get_inner_depth()
        @assertEqual( 2, inner_depth )

        halo_depth = partition%get_halo_depth()
        @assertEqual( 2, halo_depth )

! Now check quantities that differ between the partitions
        select case (local_rank)
          case(0)
            num_cells_in_layer = partition%get_num_cells_in_layer()
            @assertEqual( 32, num_cells_in_layer )

            num_cells_inner = partition%get_num_cells_inner(1)
            @assertEqual( 0, num_cells_inner )

            last_inner_cell = partition%get_last_inner_cell(1)
            @assertEqual( 0, last_inner_cell )

            num_cells_edge = partition%get_num_cells_edge()
            @assertEqual( 16, num_cells_edge )

            last_edge_cell = partition%get_last_edge_cell()
            @assertEqual( 16, last_edge_cell )

            num_cells_halo = partition%get_num_cells_halo(1)
            @assertEqual( 8, num_cells_halo )

            last_halo_cell = partition%get_last_halo_cell(1)
            @assertEqual( 24, last_halo_cell )

            num_cells_ghost = partition%get_num_cells_ghost()
            @assertEqual( 8, num_cells_ghost )
          case(1)
            num_cells_in_layer = partition%get_num_cells_in_layer()
            @assertEqual( 56, num_cells_in_layer )

            num_cells_inner = partition%get_num_cells_inner(1)
            @assertEqual( 6, num_cells_inner )

            last_inner_cell = partition%get_last_inner_cell(1)
            @assertEqual( 6, last_inner_cell )

            num_cells_edge = partition%get_num_cells_edge()
            @assertEqual( 18, num_cells_edge )

            last_edge_cell = partition%get_last_edge_cell()
            @assertEqual( 24, last_edge_cell )

            num_cells_halo = partition%get_num_cells_halo(1)
            @assertEqual( 16, num_cells_halo )

            num_cells_halo = partition%get_num_cells_halo(1)
            @assertEqual( 16, num_cells_halo )

            last_halo_cell = partition%get_last_halo_cell(1)
            @assertEqual( 40, last_halo_cell )

            num_cells_ghost = partition%get_num_cells_ghost()
            @assertEqual( 8, num_cells_ghost )
          case(2)
            num_cells_in_layer = partition%get_num_cells_in_layer()
            @assertEqual( 40, num_cells_in_layer )

            num_cells_inner = partition%get_num_cells_inner(1)
            @assertEqual( 6, num_cells_inner )

            last_inner_cell = partition%get_last_inner_cell(1)
            @assertEqual( 6, last_inner_cell )

            num_cells_edge = partition%get_num_cells_edge()
            @assertEqual( 18, num_cells_edge )

            last_edge_cell = partition%get_last_edge_cell()
            @assertEqual( 24, last_edge_cell )

            num_cells_halo = partition%get_num_cells_halo(1)
            @assertEqual( 8, num_cells_halo )

            num_cells_halo = partition%get_num_cells_halo(1)
            @assertEqual( 8, num_cells_halo )

            last_halo_cell = partition%get_last_halo_cell(1)
            @assertEqual( 32, last_halo_cell )

            num_cells_ghost = partition%get_num_cells_ghost()
            @assertEqual( 8, num_cells_ghost )
        end select

      case (4)
! Testing over four similar (4x4) partitions

        num_cells_in_layer = partition%get_num_cells_in_layer()
        @assertEqual( 48, num_cells_in_layer )

        inner_depth = partition%get_inner_depth()
        @assertEqual( 2, inner_depth )

        num_cells_inner = partition%get_num_cells_inner(1)
        @assertEqual( 4, num_cells_inner )

        last_inner_cell = partition%get_last_inner_cell(1)
        @assertEqual( 4, last_inner_cell )

        num_cells_edge = partition%get_num_cells_edge()
        @assertEqual( 12, num_cells_edge )

        last_edge_cell = partition%get_last_edge_cell()
        @assertEqual( 16, last_edge_cell )

        halo_depth = partition%get_halo_depth()
        @assertEqual( 2, halo_depth )

        num_cells_halo = partition%get_num_cells_halo(1)
        @assertEqual( 14, num_cells_halo )

        last_halo_cell = partition%get_last_halo_cell(1)
        @assertEqual( 30, last_halo_cell )

        num_cells_ghost = partition%get_num_cells_ghost()
        @assertEqual( 8, num_cells_ghost )

    end select

  end subroutine test_partition_trench_y

  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  ! Test partition_cubedsphere_serial (on a single process)
  !
  @Test( npes=[1,6] )
  subroutine test_partition_CubedSphere( this )

    implicit none

    class( partition_test_type ), intent( inout ) :: this

    type(ugrid_mesh_data_type)      :: ugrid_mesh_data
    type(global_mesh_type), pointer :: global_mesh_ptr => null()
    type(global_mesh_type)          :: global_mesh
    type(partition_type)            :: partition

    procedure (partitioner_interface), pointer :: partitioner_ptr => null()
    type(custom_decomposition_type) :: decomposition

    integer :: xproc
    integer :: yproc
    integer :: local_rank
    integer :: total_ranks
    integer :: max_stencil_depth

    integer :: num_cells_in_layer
    integer :: inner_depth
    integer :: halo_depth
    integer :: num_cells_inner
    integer :: last_inner_cell
    integer :: num_cells_edge
    integer :: last_edge_cell
    integer :: num_cells_halo
    integer :: last_halo_cell
    integer(i_def) :: num_cells_ghost

    integer(i_def) :: global_mesh_id

    logical(l_def) :: generate_inner_halos

    character(len = str_max_filename) :: filename

    xproc = 1
    yproc = 1
    local_rank = this%getProcessRank()
    total_ranks = this%getNumProcesses()
    max_stencil_depth = 2
    decomposition = custom_decomposition_type(xproc, yproc)

    generate_inner_halos = .true.

    filename = 'data/mesh_C4.nc'
    call ugrid_mesh_data%read_from_file(trim(filename), mesh_name)
    global_mesh = global_mesh_type( ugrid_mesh_data )
    call ugrid_mesh_data%clear()
    global_mesh_id = global_mesh%get_id()
    call global_mesh_collection%add_new_global_mesh( global_mesh )
    global_mesh_ptr => global_mesh_collection%get_global_mesh( global_mesh_id )

    ! Test functionality of the partition object we've just created on 1
    ! and 6 processes
    select case (total_ranks)

      case (1)
! Testing over one (4x4x6) partition - no halo/ghost cells

        partitioner_ptr => partitioner_cubedsphere_serial
        partition = partition_type( global_mesh_ptr,       &
                                    partitioner_ptr,       &
                                    decomposition,         &
                                    max_stencil_depth,     &
                                    generate_inner_halos,  &
                                    local_rank,            &
                                    total_ranks )

        ! Test functionality of the single partition object we've just created
        num_cells_in_layer = partition%get_num_cells_in_layer()
        @assertEqual( 96, num_cells_in_layer )

        inner_depth = partition%get_inner_depth()
        @assertEqual( 2, inner_depth )

        num_cells_inner = partition%get_num_cells_inner(2)
        @assertEqual( 96, num_cells_inner )

        last_inner_cell = partition%get_last_inner_cell(1)
        @assertEqual( 96, last_inner_cell )

        num_cells_edge = partition%get_num_cells_edge()
        @assertEqual( 0, num_cells_edge )

        last_edge_cell = partition%get_last_edge_cell()
        @assertEqual( 96, last_edge_cell )

        halo_depth = partition%get_halo_depth()
        @assertEqual( 2, halo_depth )

        num_cells_halo = partition%get_num_cells_halo(1)
        @assertEqual( 0, num_cells_halo )

        last_halo_cell = partition%get_last_halo_cell(1)
        @assertEqual( 96, last_halo_cell )

        num_cells_ghost = partition%get_num_cells_ghost()
        @assertEqual( 0, num_cells_ghost )

      case (6)
! Testing over six (4x4) partitions - one per face of the cubedsphere

        partitioner_ptr => partitioner_cubedsphere
        partition = partition_type( global_mesh_ptr,       &
                                    partitioner_ptr,       &
                                    decomposition,         &
                                    max_stencil_depth,     &
                                    generate_inner_halos,  &
                                    local_rank,            &
                                    total_ranks )

        ! Test functionality of the partition objects we've just created
        num_cells_in_layer = partition%get_num_cells_in_layer()
        @assertEqual( 48, num_cells_in_layer )

        inner_depth = partition%get_inner_depth()
        @assertEqual( 2, inner_depth )

        num_cells_inner = partition%get_num_cells_inner(1)
        @assertEqual( 4, num_cells_inner )

        last_inner_cell = partition%get_last_inner_cell(1)
        @assertEqual( 4, last_inner_cell )

        num_cells_edge = partition%get_num_cells_edge()
        @assertEqual( 12, num_cells_edge )

        last_edge_cell = partition%get_last_edge_cell()
        @assertEqual( 16, last_edge_cell )

        halo_depth = partition%get_halo_depth()
        @assertEqual( 2, halo_depth )

        num_cells_halo = partition%get_num_cells_halo(1)
        @assertEqual( 16, num_cells_halo )

        last_halo_cell = partition%get_last_halo_cell(1)
        @assertEqual( 32, last_halo_cell )

        num_cells_ghost = partition%get_num_cells_ghost()
        @assertEqual( 16, num_cells_ghost )

    end select

  end subroutine test_partition_CubedSphere

end module partition_mod_test
