!-----------------------------------------------------------------------------
! (C) Crown copyright 2021 Met Office. All rights reserved.
! The file LICENCE, distributed with this code, contains details of the terms
! under which the code may be used.
!-----------------------------------------------------------------------------
!>@brief   The tangent linear test for advection
!!         (Taylor remainder convergence).
!>@details Test whether a section of tangent linear code is tangent linear
!!         to the corresponding section of nonlinear code, for
!!         advection, using the Taylor remainder convergence
!!         test.
module tl_test_advection_mod

  use assign_field_random_kernel_mod, only: assign_field_random_kernel_type
  use constants_mod,                  only: i_def, r_def, str_def
  use derived_config_mod,             only: bundle_size
  use field_mod,                      only: field_type
  use field_bundle_mod,               only: clone_bundle, &
                                            minus_bundle, &
                                            add_bundle,   &
                                            copy_bundle,  &
                                            set_bundle_scalar
  use field_indices_mod,              only: igh_u, igh_t, igh_d, igh_p
  use field_collection_mod,           only: field_collection_type
  use function_space_collection_mod,  only: function_space_collection
  use finite_element_config_mod,      only: element_order
  use gungho_model_data_mod,          only: model_data_type
  use timestepping_config_mod,        only: dt
  use log_mod,                        only: log_event,         &
                                            log_scratch_space, &
                                            LOG_LEVEL_INFO
  use advection_alg_mod,              only: advection_alg
  use tl_advection_alg_mod,           only: tl_advection_alg,      &
                                            tl_advection_alg_init, &
                                            tl_advection_alg_final
  use tl_test_convergence_rate_check, only: convergence_rate_check

  implicit none

  private
  public test_advection

  contains

  !> @brief Test the tangent linear for advection.
  !> @param[in] model_data    The working data set for a model run
  !> @param[in] mesh_id       The identifier given to the current 3d mesh
  !> @param[in] twod_mesh_id  The identifier given to the current 2d mesh
  subroutine test_advection( model_data,    &
                             mesh_id,       &
                             twod_mesh_id )

    implicit none

    integer(i_def),                intent(in) :: mesh_id
    integer(i_def),                intent(in) :: twod_mesh_id
    type(model_data_type), target, intent(in) :: model_data

    character(str_def) :: label = "advection"

    type(field_collection_type ), pointer :: prognostic_fields => null()
    type(field_collection_type ), pointer :: ls_fields => null()

    type(field_type), pointer :: ls_u => null()
    type(field_type), pointer :: ls_rho => null()
    type(field_type), pointer :: ls_theta => null()
    type(field_type), pointer :: ls_exner => null()

    type( field_type ) :: state(bundle_size)
    type( field_type ) :: ls_state(bundle_size)
    type( field_type ) :: p_state(bundle_size)
    type( field_type ) :: random(bundle_size)
    type( field_type ) :: p_rhs(bundle_size)
    type( field_type ) :: n1_rhs(bundle_size)
    type( field_type ) :: n2_rhs(bundle_size)
    type( field_type ) :: diff(bundle_size)

    real(r_def) :: gamma_u, gamma_rho, gamma_exner, gamma_theta
    real(r_def) :: norm_u, norm_rho, norm_exner, norm_theta
    real(r_def) :: norm_diff, norm_diff_prev

    integer :: n
    real(r_def), parameter :: tol = 1.e-5_r_def

    call log_event( "TL Test: " // trim(label), &
                     LOG_LEVEL_INFO )

    prognostic_fields => model_data%prognostic_fields
    ls_fields         => model_data%ls_fields

    ! Input
    ls_u => ls_fields%get_field('ls_u')
    ls_rho => ls_fields%get_field('ls_rho')
    ls_theta => ls_fields%get_field('ls_theta')
    ls_exner => ls_fields%get_field('ls_exner')

    call ls_state(igh_u)%initialise( vector_space = ls_u%get_function_space() )
    call ls_state(igh_t)%initialise( vector_space = ls_theta%get_function_space() )
    call ls_state(igh_d)%initialise( vector_space = ls_rho%get_function_space() )
    call ls_state(igh_p)%initialise( vector_space = ls_exner%get_function_space() )
    call clone_bundle(ls_state, state, bundle_size)
    call clone_bundle(ls_state, p_state, bundle_size)
    call clone_bundle(ls_state, random, bundle_size)
    call clone_bundle(ls_state, p_rhs, bundle_size)
    call clone_bundle(ls_state, n1_rhs, bundle_size)
    call clone_bundle(ls_state, n2_rhs, bundle_size)
    call clone_bundle(ls_state, diff, bundle_size)

    call invoke( name = "Copy fields to ls_state",   &
                 setval_X(ls_state(igh_u), ls_u    ), &
                 setval_X(ls_state(igh_t), ls_theta), &
                 setval_X(ls_state(igh_d), ls_rho  ), &
                 setval_X(ls_state(igh_p), ls_exner) )

    call tl_advection_alg_init(mesh_id)

    call invoke( assign_field_random_kernel_type( random(igh_u) ) , &
                 assign_field_random_kernel_type( random(igh_d) ) , &
                 assign_field_random_kernel_type( random(igh_t) ) , &
                 assign_field_random_kernel_type( random(igh_p) ) )

    call set_bundle_scalar( 0.0_r_def, n1_rhs, bundle_size )
    call advection_alg( n1_rhs,                           &
                        ls_state, ls_state(igh_u),        &
                        ls_state(igh_u), ls_state(igh_u), &
                        dt_step=dt, n_substeps=1 )
    gamma_u = 1.e12
    gamma_theta = 1.e5
    gamma_rho = 1.e5
    gamma_exner = 1.e5

    do n=1,2
      gamma_u = gamma_u/2.
      gamma_theta = gamma_theta/2.
      gamma_rho = gamma_rho/2.
      gamma_exner = gamma_exner/2.

      call set_bundle_scalar( 0.0_r_def, n2_rhs, bundle_size )
      call set_bundle_scalar( 0.0_r_def, p_rhs, bundle_size )
      call invoke( a_times_X( p_state(igh_u), gamma_u, random(igh_u) ),       &
                   a_times_X( p_state(igh_t), gamma_theta, random(igh_t) ),   &
                   a_times_X( p_state(igh_d), gamma_rho, random(igh_d) ),     &
                   a_times_X( p_state(igh_p), gamma_exner, random(igh_p) ) )

      ! state = ls_state + p_state
      call add_bundle( ls_state, p_state, state, bundle_size )

      call advection_alg( n2_rhs,                     &
                          state, state(igh_u),        &
                          state(igh_u), state(igh_u), &
                          dt_step=dt, n_substeps=1 )

      call tl_advection_alg( p_rhs,                            &
                             p_state, p_state(igh_u),          &
                             p_state(igh_u), p_state(igh_u),   &
                             ls_state, ls_state(igh_u),        &
                             ls_state(igh_u), ls_state(igh_u), &
                             dt_step=dt, n_substeps=1 )

      ! diff = n2_rhs - n1_rhs
      call minus_bundle( n2_rhs, n1_rhs, diff, bundle_size )

      call invoke( &
                 inc_X_minus_Y( diff(igh_u), p_rhs(igh_u) ), &
                 inc_X_minus_Y( diff(igh_t), p_rhs(igh_t) ), &
                 inc_X_minus_Y( diff(igh_d), p_rhs(igh_d) ), &
                 inc_X_minus_Y( diff(igh_p), p_rhs(igh_p) ) )

      call invoke( X_innerproduct_X( norm_u,     diff(igh_u) ) , &
                   X_innerproduct_X( norm_rho,   diff(igh_d) ) , &
                   X_innerproduct_X( norm_theta, diff(igh_t) ) , &
                   X_innerproduct_X( norm_exner, diff(igh_p) ) )

      write( log_scratch_space, &
            '(A, E32.12, A, E32.12 )' ) &
             ' norm_u = ' ,   norm_u,   &
             ' norm_rho = ' , norm_rho

      call log_event( log_scratch_space, LOG_LEVEL_INFO )

      write( log_scratch_space, &
            '(A, E32.12, A, E32.12 )' )     &
             ' norm_theta = ' , norm_theta, &
             ' norm_exner = ' , norm_exner

      call log_event( log_scratch_space, LOG_LEVEL_INFO )

      norm_diff = norm_u + norm_rho + norm_theta + norm_exner
      norm_diff = sqrt(norm_diff)

      if (n == 2) then
        call convergence_rate_check( norm_diff, norm_diff_prev, label, tol=tol )
      end if

      norm_diff_prev = norm_diff
    end do

  end subroutine test_advection

end module tl_test_advection_mod
