!-----------------------------------------------------------------------------
! (C) Crown copyright 2021 Met Office. All rights reserved.
! The file LICENCE, distributed with this code, contains details of the terms
! under which the code may be used.
!-----------------------------------------------------------------------------
!>@brief   The tangent linear test for advecting theta
!!         (Taylor remainder convergence).
!>@details Test whether a section of tangent linear code is tangent linear
!!         to the corresponding section of nonlinear code, for
!!         advecting theta, using the Taylor remainder convergence
!!         test.
module tl_test_advect_theta_field_mod

  use assign_field_random_kernel_mod, only: assign_field_random_kernel_type
  use constants_mod,                  only: i_def, r_def, str_def
  use fem_constants_mod,              only: get_qr
  use field_mod,                      only: field_type
  use field_collection_mod,           only: field_collection_type
  use function_space_collection_mod,  only: function_space_collection
  use finite_element_config_mod,      only: element_order
  use fs_continuity_mod,              only: W2, Wtheta
  use gungho_model_data_mod,          only: model_data_type
  use timestepping_config_mod,        only: dt
  use transport_config_mod,           only: scheme,                         &
                                            scheme_cosmic_3D,               &
                                            scheme_method_of_lines
  use log_mod,                        only: log_event,         &
                                            log_scratch_space, &
                                            LOG_LEVEL_INFO
  use advection_alg_mod,              only: advect_field
  use tl_advection_alg_mod,           only: tl_advect_field,       &
                                            tl_advection_alg_init
  use tl_test_convergence_rate_check, only: convergence_rate_check

  implicit none

  private
  public test_advect_theta_field

  contains

  !> @brief Test the tangent linear for advecting theta.
  !> @param[in] model_data    The working data set for a model run
  !> @param[in] mesh_id       The identifier given to the current 3d mesh
  !> @param[in] twod_mesh_id  The identifier given to the current 2d mesh
  subroutine test_advect_theta_field( model_data,    &
                                        mesh_id,       &
                                        twod_mesh_id )

    implicit none

    integer(i_def),                intent(in) :: mesh_id
    integer(i_def),                intent(in) :: twod_mesh_id
    type(model_data_type), target, intent(in) :: model_data

    character(str_def) :: label = "advect_theta_field"

    type(field_collection_type ), pointer :: prognostic_fields => null()
    type(field_collection_type ), pointer :: ls_fields => null()

    ! Input
    type(field_type), pointer :: n_u => null()
    type(field_type), pointer :: ls_u => null()
    type(field_type), pointer :: n_theta => null()
    type(field_type), pointer :: ls_theta => null()
    type(field_type) :: p_u, p_theta

    ! Output
    type(field_type) :: n1_advection_inc
    type(field_type) :: n2_advection_inc
    type(field_type) :: p_advection_inc

    ! Test
    type(field_type) :: diff
    type(field_type) :: random_u, random_theta

    real(r_def) :: norm_diff, norm_diff_prev
    real(r_def) :: gamma_u, gamma_theta

    integer :: n
    real(r_def), parameter :: tol = 1.e-3_r_def

    call log_event( "TL Test: " // trim(label), &
                     LOG_LEVEL_INFO )

    prognostic_fields => model_data%prognostic_fields
    ls_fields         => model_data%ls_fields

    ! Input
    n_u => prognostic_fields%get_field('u')
    ls_u => ls_fields%get_field('ls_u')
    n_theta => prognostic_fields%get_field('theta')
    ls_theta => ls_fields%get_field('ls_theta')
    call p_u%initialise( vector_space = &
      function_space_collection%get_fs(mesh_id, element_order, W2) )
    call p_theta%initialise( vector_space = &
      function_space_collection%get_fs(mesh_id, element_order, Wtheta) )

    ! Output
    call n1_advection_inc%initialise( vector_space = &
      function_space_collection%get_fs(mesh_id, element_order, Wtheta) )
    call n2_advection_inc%initialise( vector_space = &
      function_space_collection%get_fs(mesh_id, element_order, Wtheta) )
    call p_advection_inc%initialise( vector_space = &
      function_space_collection%get_fs(mesh_id, element_order, Wtheta) )

    ! Test
    call diff%initialise( vector_space = &
      function_space_collection%get_fs(mesh_id, element_order, Wtheta) )
    call random_u%initialise( vector_space = &
      function_space_collection%get_fs(mesh_id, element_order, W2) )
    call random_theta%initialise( vector_space = &
      function_space_collection%get_fs(mesh_id, element_order, Wtheta) )

    call tl_advection_alg_init(mesh_id)

    ! Taylor Remainder Convergence Test
    call invoke( assign_field_random_kernel_type( random_u ) )
    call invoke( assign_field_random_kernel_type( random_theta ) )

    call invoke( setval_C( n1_advection_inc, 0.0_r_def ) )
    call advect_field( n1_advection_inc, ls_theta, ls_u, scheme,        &
                       ls_u, ls_u, advect_density=.false., timestep=dt, &
                       si_advective_terms=.false.,                      &
                       density_predictor=.false.,                       &
                       logspace=.false., dt=dt )

    gamma_u = 1.e12
    gamma_theta = 1.e2
    do n=1,2
      gamma_u = gamma_u/2.
      gamma_theta = gamma_theta/2.

      call invoke( setval_C( n2_advection_inc, 0.0_r_def ),   &
                   setval_C( p_advection_inc, 0.0_r_def ),    &
                   a_times_X( p_u, gamma_u, random_u ),       &
                   a_times_X( p_theta, gamma_theta, random_theta ), &
                   setval_X( n_u, ls_u ),                     &
                   setval_X( n_theta, ls_theta ),                 &
                   inc_X_plus_Y( n_u, p_u ),                  &
                   inc_X_plus_Y( n_theta, p_theta ) )

      call advect_field( n2_advection_inc, n_theta, n_u, scheme,       &
                       n_u, n_u, advect_density=.false., timestep=dt,  &
                       si_advective_terms=.false.,                     &
                       density_predictor=.false.,                      &
                       logspace=.false., dt=dt )

      call tl_advect_field( p_advection_inc, p_theta, p_u,               &
                          ls_theta, ls_u, scheme, p_u, p_u,              &
                          advect_density=.false., timestep=dt,           &
                          si_advective_terms=.false.,                    &
                          density_predictor=.false., &
                          logspace=.false., dt=dt )

      call invoke( X_minus_Y( diff, n2_advection_inc, n1_advection_inc ), &
                   inc_X_minus_Y( diff, p_advection_inc ),                &
                   X_innerproduct_X( norm_diff, diff ) )

      norm_diff = sqrt(norm_diff)

      write( log_scratch_space, '(A, E32.12, A, E32.12)' ) &
             'gamma = ' , gamma_u , ' norm = ' , norm_diff

      call log_event( log_scratch_space, LOG_LEVEL_INFO )

      if (n == 2) then
        call convergence_rate_check( norm_diff, norm_diff_prev, label, tol=tol )
      end if

      norm_diff_prev = norm_diff
    end do

  end subroutine test_advect_theta_field

end module tl_test_advect_theta_field_mod
